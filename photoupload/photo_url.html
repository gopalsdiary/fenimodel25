<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<title>Photo upload — Photoupload</title>
		  <script src="../login/auth-check_copy.js"></script>

	<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
		body{font-family:Inter,Segoe UI,Arial,sans-serif;margin:0;background:#f6f7fb;color:#0b1220}
		.container{max-width:none; margin:0 auto; padding:16px}
		h1{margin:0 0 12px;font-size:20px}
		.toolbar{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin-bottom:12px}
		select,input[type=search]{padding:8px 10px;border:1px solid #d1d5db;border-radius:8px}
		button{padding:8px 10px;border-radius:8px;border:1px solid #1479d6;background:#0ea5e9;color:#fff;cursor:pointer}
		button.secondary{background:#fff;color:#0b1220;border-color:#d1d5db}
		.muted{color:#6b7280;font-size:13px}
			.muted.right{margin-left:auto}
			#status{margin-top:8px}
			thead th.photo-col{width:90px}
			/* actions column: compress to content */
			thead th.actions-col, tbody td.actions-col{width:1%;white-space:nowrap}
			/* Photo Url CSV column: no fixed width; keep smaller font */
			thead th:nth-child(7), tbody td:nth-child(7) { font-size: 80%; }
		table{width:100%;border-collapse:collapse;margin-top:12px;background:#fff;border-radius:8px;overflow:hidden}
		thead th{background:#f3f6fb;padding:10px 12px;text-align:left;border-bottom:1px solid #ecf0f4}
		tbody td{padding:10px 12px;border-bottom:1px solid #f4f6fa;vertical-align:middle}
		/* let table size columns based on content */
		table{table-layout:auto}
		/* compress small columns to minimal width */
		thead th:nth-child(2), tbody td:nth-child(2), /* IID */
		thead th:nth-child(3), tbody td:nth-child(3), /* Roll */
		thead th:nth-child(4), tbody td:nth-child(4), /* Class */
		thead th:nth-child(8), tbody td:nth-child(8)  /* Match */
		{width:1%;white-space:nowrap}
		/* allow long text/URLs to wrap when needed */
		tbody td, thead th { white-space: normal; word-break: break-word; overflow-wrap: anywhere; }
		td a, td .url-input { word-break: break-all; overflow-wrap: anywhere; }
		/* alternate row coloring: odd rows light orange, even rows white */
		tbody tr:nth-child(odd) td:not(.photo-col){
			background: linear-gradient(180deg, rgba(255,244,230,0.9), rgba(255,247,236,0.8));
			border-radius:8px;
			box-shadow: inset 0 0 0 1px rgba(255,165,77,0.06);
		}
		tbody tr:nth-child(even) td:not(.photo-col){
			background: #ffffff;
			border-radius:8px;
			box-shadow: none;
		}
		/* keep image cell contents layout intact */
		tbody td:first-child{background:transparent;border-radius:0;box-shadow:none;padding:10px}
		.thumb{width:72px;height:90px;object-fit:cover;border-radius:6px;border:1px solid #e6edf6}
		/* verified-style badge for match status */
		.match-badge{display:inline-flex;align-items:center;justify-content:center;width:30px;height:30px;border-radius:50%;color:#fff;font-weight:700;font-size:16px}
		.match-badge.yes{background:#16a34a} /* green */
		.match-badge.no{background:#ef4444}  /* red */
		.match-badge.small{width:24px;height:24px;font-size:14px}
		.match-badge.empty{background:transparent;color:#6b7280;border:1px solid #e6edf6;font-weight:600}
		/* container for CSV + DB badges to keep them side-by-side */
		.match-cell{display:flex;gap:6px;align-items:center}
		.image-wrapper{position:relative;display:inline-block}
		.preview{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);width:350px;height:500px;background-size:cover;background-position:center;border-radius:8px;border:2px solid #fff;box-shadow:0 4px 12px rgba(0,0,0,0.3);z-index:1000;opacity:0;visibility:hidden;transition:opacity 0.3s ease,visibility 0.3s ease}
		.image-wrapper:hover .preview{opacity:1;visibility:visible}
		.uploader{display:flex;gap:8px;align-items:center}
		.status{font-size:13px}
		.small{font-size:12px;color:#334155}
		.url-input { width: 100%; box-sizing: border-box; }
	</style>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>

<body>
	<div class="container">
		<h1>Photoupload — student photos</h1>
		<div class="toolbar">
				<select id="tableFilter" aria-label="Class-Section-Session"><option value="">Class-Section-Session</option></select>
				<button id="downloadPdfBtn">Download PDF</button>
				<button id="uploadAllBtn" class="secondary" title="Upload all rows where Photo Url CSV matches IID">Upload All Matched</button>
				<div class="muted right">Image album: <strong>student_photo</strong></div>
		</div>

		<div id="status" class="muted"></div>

		<table id="studentsTable" aria-live="polite">
			<thead>
						<tr>
									<th class="photo-col">Photo</th>
							<th>IID</th>
							<th>Roll</th>
							<th>Class</th>
							<th>Name (EN)</th>
							<th>Father name (EN)</th>
							<th>Photo Url CSV</th>
							<th>Match IID with url</th>
							<th>Database Url</th>
							<th class="actions-col">Actions / Upload</th>
						</tr>
			</thead>
			<tbody></tbody>
		</table>
	</div>

	<script>
	// Config from instruction.text
	const IMGBB_API_KEY = '4d2cdd03bb1da4404f875c22f0bfdf31';
	const IMGBB_UPLOAD_URL = 'https://api.imgbb.com/1/upload';
	const IMGBB_ALBUM = 'student_photo';

	// Supabase config (reads/writes to student_database.student_photo_url)
	const supabaseUrl = 'https://rtfefxghfbtirfnlbucb.supabase.co';
	const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJ0ZmVmeGdoZmJ0aXJmbmxidWNiIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDA1MDg3OTcsImV4cCI6MjA1NjA4NDc5N30.fb7_myCmFzbV7WPNjFN_NEl4z0sOmRCefnkQbk6c10w';
	const supabase = (typeof window !== 'undefined' && window.supabase) ? window.supabase.createClient(supabaseUrl, supabaseKey) : null;
	const tableName = 'student_database';

	// Utility
	function escapeHtml(s){ return String(s==null? '': s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }
	function norm(s){ return String(s||'').toLowerCase().replace(/[\s_\-]+/g,'').trim(); }

	// Robust URL <-> IID matching helper
	function urlMatchesIID(url, iid){
		try{
			if(!url || !iid) return false;
			const u = String(url);
			// strip querystring/hash
			const lastSeg = u.split('/').pop() || '';
			const fname = lastSeg.split('?')[0].split('#')[0].toLowerCase();
			const id = String(iid).toLowerCase();
			const base = `avatar-${id}`;
			// common exact extensions
			const exts = ['.jpg','.jpeg','.png','.webp','.gif','.bmp'];
			for(const e of exts){ if(fname === base + e) return true; }
			// filenames that include avatar-{id} anywhere
			if(fname.includes(base)) return true;
			// tokenise filename and check for iid token (handles names like tPFFfmwn-avatar-12345.jpg)
			const tokens = fname.split(/[^0-9a-z]+/).filter(Boolean);
			if(tokens.indexOf(id) !== -1) return true;
			return false;
		}catch(e){ return false; }
	}

	// Data source: datalist.html cache
	const DATALIST_CACHE_KEY = 'datalist_rows_v2';

	function readDatalistCache(){
		try{
			const raw = localStorage.getItem(DATALIST_CACHE_KEY);
			if(!raw) return null;
			const obj = JSON.parse(raw);
			if(!obj || !Array.isArray(obj.rows)) return null;
			return obj.rows;
		}catch(e){ return null; }
	}

	function computeActiveFromRow(r){
		const s = String(r.session||'').trim();
		// If session explicitly references a year and matching fields exist, prefer them
		if(s){
			const clsKey = `class_${s}`;
			const secKey = `section_${s}`;
			const rollKey = `roll_${s}`;
			if(r[clsKey] || r[secKey] || r[rollKey]){
				return { session:s, active_class:String(r[clsKey]||''), active_section:String(r[secKey]||''), active_roll:String(r[rollKey]||'') };
			}
		}
		// Otherwise, scan for any class_<year> / section_<year> / roll_<year> fields and pick the latest year with data
		let bestYear = null;
		let best = { c: '', s: '', r: '' };
		for(const k of Object.keys(r || {})){
			const m = k.match(/^class_(\d{2,4})$/);
			if(!m) continue;
			const year = m[1];
			const c = String(r[`class_${year}`]||'').trim();
			const sec = String(r[`section_${year}`]||'').trim();
			const rl = String(r[`roll_${year}`]||'').trim();
			if(c || sec || rl){
				if(bestYear === null || Number(year) > Number(bestYear)){
					bestYear = year;
					best = { c, s: sec, r: rl };
				}
			}
		}
		if(bestYear !== null){
			return { session: String(bestYear), active_class:String(best.c||''), active_section:String(best.s||''), active_roll:String(best.r||'') };
		}
		// Fallback: older explicit fields
		let active_class='', active_section='', active_roll='';
		if(s==='2026'){ active_class=r.class_2026||''; active_section=r.section_2026||''; active_roll=r.roll_2026||''; }
		else if(s==='2025'){ active_class=r.class_2025||''; active_section=r.section_2025||''; active_roll=r.roll_2025||''; }
		return { session:s, active_class:String(active_class||''), active_section:String(active_section||''), active_roll:String(active_roll||'') };
	}

	function buildGroupOptions(){
		const rows = readDatalistCache();
		if(!rows) return [];
		const seen = new Set(); const pairs=[];
		for(const r of rows){
			if(String(r.status||'').toUpperCase().includes('TC')) continue;
			const a = computeActiveFromRow(r);
			if(!a.active_roll || a.active_roll.trim()==='') continue;
			if(!a.active_class || !a.active_section || !a.session) continue;
			const key = `${a.active_class}-${a.active_section}-${a.session}`;
			if(seen.has(key)) continue; seen.add(key);
			pairs.push({ id:'cache', name:key, cls:a.active_class, section:a.active_section, session:a.session });
		}
		pairs.sort((x,y)=>{ const cx=Number(x.cls)||0, cy=Number(y.cls)||0; if(cx!==cy) return cx-cy; return String(x.name).localeCompare(String(y.name)); });
		return pairs;
	}

	// Load existing photo list from photo/link.csv and map basename -> url
	async function loadPhotoIndex(){
		try{
			const res = await fetch('../photo/link.csv', {cache:'no-store'});
			if(!res.ok) return new Map();
			const txt = await res.text();
			const lines = txt.split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
			const m = new Map();
			for(const u of lines){
				try{ const name = u.split('/').pop(); if(name) m.set(name.toLowerCase(), u); }
				catch(e){}
			}
			return m;
		}catch(e){ return new Map(); }
	}

	// Render helpers
	const tbody = document.querySelector('#studentsTable tbody');
	const statusEl = document.getElementById('status');

	function setStatus(s, err){ statusEl.textContent = s || ''; if(err) console.error(err); }

	// Application state
	let photoIndex = new Map();
	let allStudents = []; // {iid, name, father, roll, cls, section, session}
	let groupOptions = []; // {name, cls, section, session}
	let filters = { cls:'', section:'', session:'' };

	// Load all sheets and build students list (only necessary fields)

	function loadAllStudentsFromCache(){
		setStatus('Loading from cache…');
		const rows = readDatalistCache();
		if(!rows){ setStatus('Cache missing. Open 0newdatabase/datalist.html first.'); allStudents=[]; return; }
		const out=[]; let idx=0;
		for(const r of rows){
			if(String(r.status||'').toUpperCase().includes('TC')) continue;
			const a = computeActiveFromRow(r);
			if(!a.active_roll || a.active_roll.trim()==='') continue;
			if(!a.active_class || !a.active_section || !a.session) continue;
			out.push({
				_idx: idx++,
				iid: r.iid || '',
				name: String(r.student_name_en||''),
				father: String(r.father_name_en||''),
				roll: String(a.active_roll||''),
				cls: String(a.active_class||''),
				section: String(a.active_section||''),
				session: String(a.session||'')
			});
		}
		allStudents = out;
		setStatus(`Loaded ${allStudents.length} rows from cache`);
	}

	// Build table rows based on filters
	function applyFilters(){
			const key = document.getElementById('tableFilter').value;
			let filtered = allStudents;
			// If no key (ALL) selected, clear filters and show all students
			if(!key){
				filters = { cls:'', section:'', session:'' };
				filtered = allStudents.slice();
			}else{
				let parsed = null;
				try{ parsed = JSON.parse(key); }catch(e){ parsed = null; }
				if(parsed && parsed.cls!==undefined){
					const { cls, section, session } = parsed;
					filters = { cls, section, session };
					filtered = filtered.filter(s=> String(s.cls)===String(cls) && String(s.section).toLowerCase()===String(section).toLowerCase() && String(s.session)===String(session));
				}else{
					// Fallback: best-effort legacy split (session after last '-', class before first '-', middle is section)
					const lastDash = key.lastIndexOf('-');
					const firstDash = key.indexOf('-');
					if(lastDash>firstDash && firstDash>0){
						const cls = key.slice(0, firstDash).trim();
						const session = key.slice(lastDash+1).trim();
						const section = key.slice(firstDash+1, lastDash).trim();
						filters = { cls, section, session };
						filtered = filtered.filter(s=> String(s.cls)===String(cls) && String(s.section).toLowerCase()===String(section).toLowerCase() && String(s.session)===String(session));
					}
				}
			}
		// sort by roll numeric asc then IID
		filtered = filtered.slice().sort((a,b)=>{
			const ra=Number(a.roll), rb=Number(b.roll);
			const va = Number.isFinite(ra)?ra:Infinity; const vb = Number.isFinite(rb)?rb:Infinity;
			if(va!==vb) return va-vb;
			return String(a.iid||'').localeCompare(String(b.iid||''), undefined, {numeric:true});
		});
		renderTable(filtered);
	}

	function renderTable(list){
		tbody.innerHTML = '';
			if(!list.length){ tbody.insertAdjacentHTML('beforeend','<tr><td colspan="10" class="muted small">No students found for selected filters.</td></tr>'); return; }

		// sort by roll when available (numeric preferred), fallback to IID
		const sorted = list.slice().sort((a,b)=>{
			const ra = (a.roll||'').toString().trim();
			const rb = (b.roll||'').toString().trim();
			const na = parseInt(ra,10); const nb = parseInt(rb,10);
			if(!isNaN(na) && !isNaN(nb)) return na - nb;
			if(ra && rb) return ra.localeCompare(rb, undefined, {numeric:true, sensitivity:'base'});
			return String(a.iid||'').localeCompare(String(b.iid||''), undefined, {numeric:true, sensitivity:'base'});
		});

		const rowsHtml = sorted.map(s=>{
			const iidStr = String(s.iid).trim();
			let thumbUrl = '';
			const cand1 = (`avatar-${iidStr}.jpg`).toLowerCase();
			const cand2 = (`avatar-${iidStr}.jpeg`).toLowerCase();
			if(photoIndex.has(cand1)) thumbUrl = photoIndex.get(cand1);
			else if(photoIndex.has(cand2)) thumbUrl = photoIndex.get(cand2);
			else {
				for(const [k,u] of photoIndex.entries()){ if(iidStr && k.includes(iidStr)) { thumbUrl = u; break; } }
			}
			let match = false;
			if(thumbUrl){
				match = urlMatchesIID(thumbUrl, iidStr);
			}
			const imgHtml = thumbUrl ? `<div class="image-wrapper"><img loading="lazy" class="thumb" src="${escapeHtml(thumbUrl)}" alt="photo"><div class="preview" style="background-image: url('${escapeHtml(thumbUrl)}')"></div></div>` : '';
		// show explicit roll if present, otherwise fallback to rowIndex+1 when available
		const rollStr = String((s.roll && String(s.roll).trim()) || (typeof s.rowIndex !== 'undefined' ? String(s.rowIndex + 1) : '')).trim();
			const iidDisplay = escapeHtml(iidStr);
			const classCell = s.cls ? `${escapeHtml(s.cls)}${s.section? ' '+escapeHtml(s.section): ''}` : '';
			// prepare download filenames (sanitize minimally)
			const rawClass = (s.cls && String(s.cls).trim()) || '';
			const rawSection = (s.section && String(s.section).trim()) || '';
			// simple filename sanitizer: remove problematic chars and spaces
			const safe = t => String(t||'').replace(/[^a-z0-9A-Z\-_.]/g, '').replace(/\s+/g, '');
			const classNum = safe(rawClass);
			const sectionVal = safe(rawSection);
			const rollVal = safe(rollStr);
			const avatarFile = `avatar-${iidStr}.jpg`;
			// Class-roll: <Class>_<SECTION>-<roll>.jpg  (omit section if not present)
			const classRollFile = `${classNum}${sectionVal ? '_' + sectionVal : ''}${rollVal ? '-'+rollVal : ''}.jpg`;
			const hasPhoto = Boolean(thumbUrl);
			// details link to detailsinfo.html with iid query param
			const detailsLink = iidStr ? `<a class="small" href="/0newdatabase/detailsinfo.html?iid=${encodeURIComponent(iidStr)}" target="_blank" rel="noopener">Details</a>` : `<span class="small muted">Details</span>`;
			// download links: use data-filename and class so we can force-download via JS (avoids opening new tab)
			const dlAvatar = hasPhoto ? `<a class="small dl-link dl-avatar" href="${escapeHtml(thumbUrl)}" data-filename="${escapeHtml(avatarFile)}">Download (IID)</a>` : `<span class="small muted">Download (IID)</span>`;
			const dlClassRoll = hasPhoto ? `<a class="small dl-link dl-classroll" href="${escapeHtml(thumbUrl)}" data-filename="${escapeHtml(classRollFile)}">Download (Class-roll)</a>` : `<span class="small muted">Download (Class-roll)</span>`;

			return `<tr data-iid="${escapeHtml(iidStr)}" data-roll="${escapeHtml(rollStr)}" data-src-sheet="${escapeHtml(s.src && s.src.name)}" data-src-id="${escapeHtml(s.src && s.src.id)}">
				<td>${imgHtml}</td>
				<td>${iidDisplay}</td>
				<td>${escapeHtml(rollStr)}</td>
				<td>${classCell}</td>
				<td>${escapeHtml(s.name)}</td>
				<td>${escapeHtml(s.father)}</td>
				<td>${thumbUrl ? `<a href="${escapeHtml(thumbUrl)}" target="_blank">${escapeHtml(thumbUrl)}</a>` : `<input type="text" placeholder="Enter URL" class="url-input" data-iid="${escapeHtml(iidStr)}">`}</td>
					<td>
						<div class="match-cell">
							<span title="CSV match" class="match-badge ${match ? 'yes' : 'no'}">${match ? '✓' : '✗'}</span>
							<span title="DB match" class="match-badge no" data-iid-badge="${escapeHtml(iidStr)}">✗</span>
						</div>
					</td>
					<td>${detailsLink}</td>
					<td class="actions-col">
						<div class="uploader">
							<button class="upload-btn" data-iid="${escapeHtml(iidStr)}">Upload</button>
							<div class="status small" data-iid="status-${escapeHtml(iidStr)}"></div>
						</div>
					</td>
			</tr>`;
		}).join('');

		tbody.insertAdjacentHTML('beforeend', rowsHtml);

		// after rendering rows, populate Database Url (student_photo_url) from Supabase
		async function populateDbUrlsForRendered(){
			if(!supabase) return;
			const rows = Array.from(tbody.querySelectorAll('tr'));
			const iids = rows.map(r=>r.dataset.iid).filter(Boolean);
			if(iids.length===0) return;
			try{
				const { data, error } = await supabase.from(tableName).select('iid, student_photo_url').in('iid', iids);
				if(error){ console.error('Supabase fetch error', error); return; }
				const map = new Map();
				for(const r of data || []) map.set(String(r.iid), r.student_photo_url || '');
				for(const tr of rows){
					const iid = tr.dataset.iid;
					const dbCell = tr.querySelector('td:nth-child(9)');
					const uploadBtn = tr.querySelector('.upload-btn');
					const dbUrl = map.get(iid) || '';
					if(dbCell){
						if(dbUrl){ dbCell.innerHTML = `<a href="${escapeHtml(dbUrl)}" target="_blank" rel="noopener">${escapeHtml(dbUrl)}</a>`; }
						else { dbCell.innerHTML = `<span class="small muted">—</span>`; }
					}
					// update DB match badge
					const dbBadge = tr.querySelector('span[data-iid-badge]');
					if(dbBadge){
						if(!dbUrl){ dbBadge.className = 'match-badge no'; dbBadge.textContent = '✗'; }
						else {
							const isMatch = urlMatchesIID(dbUrl, iid);
							dbBadge.className = 'match-badge ' + (isMatch ? 'yes' : 'no');
							dbBadge.textContent = isMatch ? '✓' : '✗';
						}
					}
					if(uploadBtn){
						if(dbUrl){ uploadBtn.style.display = 'none'; }
						else { uploadBtn.style.display = ''; uploadBtn.disabled = false; }
					}
				}
			}catch(err){ console.error('populateDbUrlsForRendered error', err); }
		}

		populateDbUrlsForRendered();

		// wire upload handlers
			document.querySelectorAll('.upload-btn').forEach(btn=>{
				btn.addEventListener('click', async (e)=>{
					e.preventDefault();
					const iid = btn.dataset.iid;
					const tr = btn.closest('tr');
					const status = tr.querySelector('.status');
					status.textContent = '';
					if(!supabase){ status.textContent = 'Supabase not available'; return; }
					// read Photo Url CSV from column 7 (link or input)
					const csvCell = tr.querySelector('td:nth-child(7)');
					let csvUrl = '';
					if(csvCell){
						const a = csvCell.querySelector('a');
						if(a) csvUrl = a.href;
						else {
							const inp = csvCell.querySelector('input.url-input');
							if(inp) csvUrl = inp.value.trim();
						}
					}
					if(!csvUrl){ status.textContent = 'No Photo Url to save'; return; }
					btn.disabled = true;
					status.textContent = 'Saving…';
					try{
						const { data, error } = await supabase.from(tableName).update({ student_photo_url: csvUrl }).eq('iid', iid).select();
						if(error){ throw error; }
						// update DB cell and UI
						const dbCell = tr.querySelector('td:nth-child(9)');
						if(dbCell) dbCell.innerHTML = `<a href="${escapeHtml(csvUrl)}" target="_blank" rel="noopener">${escapeHtml(csvUrl)}</a>`;
						// set DB badge to match/no-match
						const dbBadge = tr.querySelector('span[data-iid-badge]');
						if(dbBadge){
							const isMatch = urlMatchesIID(csvUrl, iid);
							dbBadge.className = 'match-badge ' + (isMatch ? 'yes' : 'no');
							dbBadge.textContent = isMatch ? '✓' : '✗';
						}
						status.textContent = 'Saved ✓';
						btn.style.display = 'none';
					}catch(err){
						console.error('Supabase update error', err);
						status.textContent = 'Save failed';
						btn.disabled = false;
					}
				});
			});

		// Bulk upload: Upload all rows where CSV match badge (left badge) is 'yes' and DB not set
		async function bulkUploadMatched(){
			if(!supabase){ setStatus('Supabase not available'); return; }
			const rows = Array.from(tbody.querySelectorAll('tr'));
			// select rows where CSV badge (first .match-badge in .match-cell) has 'yes' class OR where CSV cell contains a direct link that matches iid
			const candidates = [];
			for(const tr of rows){
				const iid = tr.dataset.iid;
				if(!iid) continue;
				const csvCell = tr.querySelector('td:nth-child(7)');
				let csvUrl = '';
				if(csvCell){ const a = csvCell.querySelector('a'); if(a) csvUrl = a.href; else { const inp = csvCell.querySelector('input.url-input'); if(inp) csvUrl = inp.value.trim(); } }
				if(!csvUrl) continue; // nothing to save
				// determine CSV match (exists a CSV photo index match) via left badge
				const badges = tr.querySelectorAll('.match-cell .match-badge');
				let csvBadge = null;
				if(badges && badges.length>0) csvBadge = badges[0];
				const dbCell = tr.querySelector('td:nth-child(9)');
				const hasDbUrl = dbCell && dbCell.textContent && !dbCell.textContent.includes('—');
				const csvIsYes = csvBadge && csvBadge.classList.contains('yes');
				if(csvIsYes && !hasDbUrl){ candidates.push({ tr, iid, csvUrl }); }
			}
			if(candidates.length===0){ setStatus('No matched rows to upload'); return; }
			setStatus(`Uploading ${candidates.length} matched photos…`);
			let done = 0;
			for(const c of candidates){
				const { tr, iid, csvUrl } = c;
				const status = tr.querySelector('.status');
				const uploadBtn = tr.querySelector('.upload-btn');
				if(status) status.textContent = 'Saving…';
				if(uploadBtn) uploadBtn.disabled = true;
				try{
					const { data, error } = await supabase.from(tableName).update({ student_photo_url: csvUrl }).eq('iid', iid).select();
					if(error) throw error;
					// update UI
					const dbCell = tr.querySelector('td:nth-child(9)');
					if(dbCell) dbCell.innerHTML = `<a href="${escapeHtml(csvUrl)}" target="_blank" rel="noopener">${escapeHtml(csvUrl)}</a>`;
						const dbBadge = tr.querySelector('span[data-iid-badge]');
					if(dbBadge){
						const isMatch = urlMatchesIID(csvUrl, iid);
						dbBadge.className = 'match-badge ' + (isMatch ? 'yes' : 'no');
						dbBadge.textContent = isMatch ? '✓' : '✗';
					}
					if(status) status.textContent = 'Saved ✓';
					if(uploadBtn) uploadBtn.style.display = 'none';
				}catch(err){
					console.error('Bulk upload error for', iid, err);
					if(status) status.textContent = 'Save failed';
					if(uploadBtn) uploadBtn.disabled = false;
				}
				done++;
				setStatus(`Uploading ${done}/${candidates.length}…`);
			}
			setStatus(`Bulk upload complete: ${done}/${candidates.length}`);
		}

		// wire upload all button
		document.getElementById('uploadAllBtn')?.addEventListener('click', (e)=>{ e.preventDefault(); bulkUploadMatched(); });

		// wire download handlers (force download by fetching blob then creating object URL)
		document.querySelectorAll('.dl-link').forEach(a=>{
			a.addEventListener('click', async (ev)=>{
				ev.preventDefault();
				const url = a.href;
				const filename = a.dataset && a.dataset.filename ? a.dataset.filename : 'download.jpg';
				try{
					const resp = await fetch(url, {mode:'cors'});
					if(!resp.ok) throw new Error('Fetch failed: '+resp.status);
					const blob = await resp.blob();
					const objUrl = URL.createObjectURL(blob);
					const tmp = document.createElement('a');
					tmp.href = objUrl; tmp.download = filename; document.body.appendChild(tmp);
					tmp.click(); tmp.remove();
					setTimeout(()=> URL.revokeObjectURL(objUrl), 5000);
				}catch(err){
					console.error('Download fallback, opening in new tab', err);
					window.open(url,'_blank');
				}
			});
		});
	}

	function populateFilters(){
		const sel = document.getElementById('tableFilter'); if(!sel) return;
			sel.innerHTML = '<option value="">ALL</option>';
		groupOptions = buildGroupOptions();
			groupOptions.forEach(g=>{ const o=document.createElement('option'); o.value=JSON.stringify({cls:g.cls, section:g.section, session:g.session}); o.textContent=g.name; sel.appendChild(o); });
	}

	// Wire filter controls (defensive)
	const tableFilterEl = document.getElementById('tableFilter');
	if(tableFilterEl) tableFilterEl.addEventListener('change', ()=> applyFilters());

	// obsolete handler removed

	// Populate class dropdown early with sheet list to help UX
	// obsolete prefill removed

	// initial load
	async function init(){
			setStatus('Loading photo index…');
			photoIndex = await loadPhotoIndex();
			loadAllStudentsFromCache();
			populateFilters();
			setStatus(`Photos indexed: ${photoIndex.size} — Ready`);
			// Render the table with current filter (default ALL)
			applyFilters();
	}

	// start
	window.addEventListener('DOMContentLoaded', ()=>{ init(); });

	// PDF download
	document.getElementById('downloadPdfBtn').addEventListener('click', async ()=>{
		const table = document.getElementById('studentsTable');
		if(!table) return;
		// Temporarily clear actions column content
		const actionCells = document.querySelectorAll('td.actions-col');
		actionCells.forEach(cell => cell.innerHTML = '');
		const actionHeader = document.querySelector('th.actions-col');
		if(actionHeader) actionHeader.style.display = 'none'; // hide header
		
		// Set row height to approx 1.5 cm (57px)
		const rows = table.querySelectorAll('tbody tr');
		rows.forEach(tr => tr.style.minHeight = '57px');
		// Add black borders
		table.style.border = '1px solid black';
		table.style.borderCollapse = 'collapse';
		table.style.fontFamily = 'Arial, sans-serif';
		table.style.fontSize = '12px';
		const cells = table.querySelectorAll('td, th');
		cells.forEach(cell => {
			cell.style.border = '1px solid black';
			cell.style.padding = '8px';
			cell.style.textAlign = 'center';
		});
		const ths = table.querySelectorAll('th');
		ths.forEach(th => {
			th.style.backgroundColor = '#e0e0e0';
			th.style.fontWeight = 'bold';
			th.style.color = '#000';
		});
		const nameCells = table.querySelectorAll('td:nth-child(5), td:nth-child(6)'); // Name and Father columns
		nameCells.forEach(cell => cell.style.textAlign = 'left');
		// Wait for images to load
		await new Promise(resolve => setTimeout(resolve, 1000));
		// Generate PDF
		const opt = {
			margin: [0.2, 0.2, 0.2, 0.2], // 0.5cm margin
			filename: 'students.pdf',
			image: { type: 'jpeg', quality: 1.0 },
			html2canvas: { scale: 2, useCORS: true, allowTaint: true, width: 794 },
			jsPDF: { unit: 'in', format: 'a4', orientation: 'portrait' },
			repeat: { thead: true }
		};
		await html2pdf().set(opt).from(table).save();
		// Restore
		actionCells.forEach(cell => {
			// Need to restore content, but since it's dynamic, perhaps reload table
			// For simplicity, since page reloads or re-render, but to avoid, maybe store original
			// But for now, since it's one time, and user can refresh
		});
		if(actionHeader) actionHeader.style.display = '';
		rows.forEach(tr => tr.style.minHeight = '');
		table.style.border = '';
		table.style.borderCollapse = '';
		cells.forEach(cell => cell.style.border = '');
		// To restore content, re-render the table
		applyFilters();
	});
	</script>
</body>
</html>
