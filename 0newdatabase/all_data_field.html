<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link href="https://fonts.googleapis.com/css2?family=Kalpurush&display=swap" rel="stylesheet">
  <title>Entry - Show & Edit</title>
  <style>
    /* reduce base font size by 20% and use Kalpurush font */
    html{font-size:100%;}
    body{font-family: 'Kalpurush', Arial, Helvetica, sans-serif; padding:16px}
    table{width:100%;border-collapse:collapse;margin-top:12px;table-layout:auto}
    th,td{border:1px solid #ddd;padding:8px;text-align:left;vertical-align:middle;white-space:nowrap}
    th{background:#f4f4f4}
  /* zebra striping */
  tbody tr:nth-child(odd){ background:#ffffff }
  tbody tr:nth-child(even){ background:#f5f5f5 }
    .btn{padding:6px 10px;border:none;background:#0b74de;color:#fff;border-radius:4px;cursor:pointer}
    .btn.secondary{background:#6c757d}
    /* modal */
    .modal{position:fixed;left:0;top:0;right:0;bottom:0;background:rgba(0,0,0,0.5);display:none;align-items:center;justify-content:center}
    .modal .panel{background:#fff;padding:16px;border-radius:6px;max-width:720px;width:100%;max-height:80vh;overflow:auto}
    .field-row{display:flex;gap:8px;margin-bottom:8px;align-items:center}
    .field-row label{min-width:140px}
    .field-row input, .field-row textarea{flex:1;padding:8px}
    .notice{margin-top:8px;color:#a00}
    .error-details{font-family:monospace;font-size:12px;color:#900;margin-top:6px}
    /* status column */
  /* ensure TC rows override zebra */
  tbody tr.status-tc{background-color:rgba(250, 187, 187, 0.5) !important}
    /* SL (serial) column small */
    .col-sl{width:56px;max-width:56px;padding:4px;text-align:center}
  </style>
</head>
<body>
  <h2>student_database : Data Overview </h2>
  <div>
    <span id="status" style="margin-left:12px;color:#444"></span>
  </div>

  <table id="dataTable">
    <thead>
      <tr>
        <!-- Headers will be dynamically generated -->
      </tr>
    </thead>
    <tbody>
      <tr><td>Loading...</td></tr>
    </tbody>
  </table>

  <!-- Edit modal -->
  <div id="editModal" class="modal">
    <div class="panel">
      <h3>Edit Record</h3>

      <!-- Dynamic fields will be rendered here -->
      <div id="editFields"></div>

      <div style="text-align:right;margin-top:12px">
        <button id="cancelBtn" class="btn secondary">Cancel</button>
        <button id="saveBtn" class="btn">Save</button>
      </div>
      <div id="modalNotice" class="notice"></div>
    </div>
  </div>

  <!-- Supabase client -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script>
    // Use the same project URL/key used elsewhere in this repo
    const supabaseUrl = 'https://rtfefxghfbtirfnlbucb.supabase.co';
    const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJ0ZmVmeGdoZmJ0aXJmbmxidWNiIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDA1MDg3OTcsImV4cCI6MjA1NjA4NDc5N30.fb7_myCmFzbV7WPNjFN_NEl4z0sOmRCefnkQbk6c10w';
    const supabase = window.supabase.createClient(supabaseUrl, supabaseKey);

    const tableName = 'student_database';
  // Simple 10-minute TTL cache (localStorage) with SWR behavior
  const CACHE_KEY = 'all_data_field_cache_v1';
  const CACHE_TTL_MS = 10 * 60 * 1000; // 10 minutes

  const tbody = document.querySelector('#dataTable tbody');
    const statusEl = document.getElementById('status');

  // keep full dataset in memory for client-side filtering
  let allRowsCache = [];

    // modal elems
    const editModal = document.getElementById('editModal');
    const editFields = document.getElementById('editFields');
    const cancelBtn = document.getElementById('cancelBtn');
    const saveBtn = document.getElementById('saveBtn');
    const modalNotice = document.getElementById('modalNotice');

  // Check if required elements exist
  if(!tbody || !statusEl) {
    console.error('Required DOM elements not found!');
    console.log('tbody:', tbody, 'statusEl:', statusEl);
  }

  // Refresh and filter controls removed per request
    cancelBtn.addEventListener('click', closeModal);
    saveBtn.addEventListener('click', saveEdit);

    // store the currently editing IID
    let currentIID = null;

    // column order from dataorder.csv
    let columnOrder = [];
    let displayNames = {};

    // ---- Cache helpers ----
    function saveCache(rows){
      try{
        const payload = { ts: Date.now(), rows };
        localStorage.setItem(CACHE_KEY, JSON.stringify(payload));
      }catch(e){ /* ignore quota or serialization issues */ }
    }

    function loadCache(){
      try{
        const raw = localStorage.getItem(CACHE_KEY);
        if(!raw) return null;
        const obj = JSON.parse(raw);
        if(!obj || !Array.isArray(obj.rows) || typeof obj.ts !== 'number') return null;
        return obj;
      }catch(e){ return null; }
    }

    function showFromCacheIfFresh(){
      const cached = loadCache();
      if(!cached) return false;
      const age = Date.now() - cached.ts;
      if(age > CACHE_TTL_MS) return false;
  allRowsCache = cached.rows;
  renderTable(allRowsCache);
      const mins = Math.max(0, Math.floor(age/60000));
      statusEl.textContent = `Total: ${allRowsCache.length} (from cache, ${mins}m old)`;
      // Kick off a background refresh (SWR) without blocking UI
      setTimeout(()=>{ loadData(true /*background*/); }, 0);
      return true;
    }

  async function loadColumnOrder(){
      try{
        console.log('Loading column order from dataorder.csv...');
        const res = await fetch('dataorder.csv');
        if(!res.ok) {
          console.warn('dataorder.csv not found, using default columns');
          return;
        }
        const txt = await res.text();
        console.log('dataorder.csv content loaded');
        const lines = txt.split(/\r?\n/).filter(line => line.trim() && !line.includes('colm name'));
        lines.forEach(line => {
          const parts = line.split(' > ');
          if(parts.length >= 2){
            const dbField = parts[0].trim();
            const display = parts[1].trim();
            columnOrder.push(dbField);
            displayNames[dbField] = display;
          }
        });
        console.log('Column order loaded:', columnOrder.length, 'columns');
      }catch(e){
        console.error('Error loading column order:', e);
        columnOrder = [];
        displayNames = {};
      }
    }

    async function loadData(background=false){
      console.log('loadData started, background:', background);
      if(!background) statusEl.textContent = 'Loading all data...';
      try{
        // Test Supabase connection first
        console.log('Testing Supabase connection...');
        const testQuery = await supabase
          .from(tableName)
          .select('iid')
          .limit(1);
          
        console.log('Test query result:', testQuery);
        if(testQuery.error) {
          throw new Error('Supabase connection failed: ' + testQuery.error.message);
        }
        
        // Load column order if not loaded
        if(columnOrder.length === 0){
          console.log('Loading column order...');
          await loadColumnOrder();
        }
        console.log('Column order loaded, starting data fetch...');
        
  // Use multiple fetch calls to get ALL data (bypass Supabase 1k per-request cap)
  let allData = [];
  let lastId = 0;
  // Use 1000 to align with PostgREST default max rows per request
  let batchSize = 10000;
  let hasMore = true;
  let batchCount = 0;
  let prevLastId = null; // plateau guard
  const maxBatches = 10000; // generous safety limit for very large tables
        
        while(hasMore && batchCount < maxBatches) {
          batchCount++;
          console.log(`Loading batch ${batchCount}, lastId: ${lastId}`);
          statusEl.textContent = `Loading... (${allData.length} records loaded, batch ${batchCount})`;
          
          // select only needed columns when possible to reduce payload
          const selectColsArr = (columnOrder && columnOrder.length>0)
            ? Array.from(new Set([...columnOrder, 'iid']))
                .filter(Boolean)
                .map(c => String(c).replace(/["\s]+/g, '').trim())
            : null;
          const selectArg = selectColsArr ? selectColsArr.join(',') : '*';
          console.log('Querying with selectArg:', selectArg);

          // Primary attempt with specific columns
          let data, error;
          try{
            ({ data, error } = await supabase
              .from(tableName)
              .select(selectArg)
              .gt('iid', lastId)
              .order('iid', { ascending: true })
              .limit(batchSize));
          }catch(e){
            console.warn('Select with specific columns threw, falling back to *:', e);
            data = null; error = e;
          }

          // Fallback: if error due to column list, retry with '*'
          if(error || !Array.isArray(data)){
            console.warn('Retrying batch with select("*") due to error or invalid data. original error:', error);
            ({ data, error } = await supabase
              .from(tableName)
              .select('*')
              .gt('iid', lastId)
              .order('iid', { ascending: true })
              .limit(batchSize));
          }
            
          console.log('Query result:', { dataLength: data?.length, error });
          if(error){
            console.error('Supabase error:', error);
            const details = JSON.stringify(error, Object.getOwnPropertyNames(error));
            throw new Error(`${error.message} | details: ${details}`);
          }
          
          if(!data || data.length === 0) {
            hasMore = false;
            break;
          }
          
          // append results (faster than repeated concat)
          for(const row of data) allData.push(row);
          lastId = data[data.length - 1].iid;
          // Plateau guard: if lastId didn't advance, break to avoid infinite loop
          if(prevLastId !== null && Number(lastId) === Number(prevLastId)){
            console.warn('Pagination stalled because lastId did not advance. Stopping to avoid infinite loop.', { lastId, prevLastId });
            hasMore = false;
            break;
          }
          prevLastId = lastId;
        }
        
        allRowsCache = allData;
        renderTable(allRowsCache);
        statusEl.textContent = `✅ Total: ${allRowsCache.length} records loaded (${batchCount} batches, all data loaded)`;
        // Persist to cache for 10 minutes use
        saveCache(allRowsCache);
      }catch(err){
        console.error('loadData error:', err);
        console.error('Error stack:', err.stack);
        statusEl.textContent = 'Data loading error: ' + (err.message || err);
        const msg = err && err.message ? err.message : String(err);
        const colSpan = document.querySelectorAll('#dataTable thead th').length || 1;
        tbody.innerHTML = `<tr><td colspan="${colSpan}">Data loading error: <div class="error-details">${escapeHtml(msg)}</div></td></tr>`;
        // If we have cache, show it as fallback
        const cached = loadCache();
        if(cached && Array.isArray(cached.rows)){
        allRowsCache = cached.rows;
          renderTable(allRowsCache);
          const ageM = Math.floor((Date.now()-cached.ts)/60000);
          statusEl.textContent = `Total: ${allRowsCache.length} (offline cache, ${ageM}m old)`;
        }
      }
    }

  // Filter helpers removed per request

    function renderTable(rows){
      if(!rows || rows.length === 0){
        const thead = document.querySelector('#dataTable thead');
        thead.innerHTML = '<tr><th>Columns</th></tr>';
        tbody.innerHTML = `<tr><td colspan="1">No records found</td></tr>`;
        return;
      }

      // Get all unique keys from all rows
      const allKeys = new Set();
      rows.forEach(r => {
        if(r) Object.keys(r).forEach(k => allKeys.add(k));
      });
      // Sort keys based on columnOrder, missing ones at end
      const orderedKeys = columnOrder.filter(k => allKeys.has(k));
      const remainingKeys = Array.from(allKeys).filter(k => !columnOrder.includes(k)).sort();
      const keys = orderedKeys.concat(remainingKeys);

      // Render header with SL column
      const thead = document.querySelector('#dataTable thead');
      thead.innerHTML = '<tr><th class="col-sl">SL</th>' + keys.map(k => `<th>${escapeHtml(k)}</th>`).join('') + '</tr>';

      // Render body
  tbody.innerHTML = '';
  const colCount = keys.length + 1; // +1 for SL column

      rows.forEach((r, index) => {
        const tr = document.createElement('tr');
        const iid = (r['iid'] ?? r.iid ?? r['IID'] ?? r.IID) || '';

        // Add SL column first
        const slTd = document.createElement('td');
        slTd.className = 'col-sl';
        slTd.textContent = index + 1;
        tr.appendChild(slTd);

        keys.forEach(k => {
          const td = document.createElement('td');
          const val = r[k] === null || r[k] === undefined ? '' : String(r[k]);
          td.textContent = escapeHtml(val);
          if (k === 'status' && val && val.toUpperCase().includes('TC')) {
            tr.className = 'status-tc';
          }
          tr.appendChild(td);
        });

        tbody.appendChild(tr);
      });

      // Update colspans in other places
      const loadingRow = document.querySelector('#dataTable tbody tr');
      if(loadingRow) loadingRow.innerHTML = `<td colspan="${colCount}">Loading...</td>`;
    }

  async function openEditByIID(iid){
      // fetch full row from DB to ensure we have all columns
      modalNotice.textContent = '';
      currentIID = iid;
      try{
        const { data, error } = await supabase
          .from(tableName)
          .select('*')
      .eq('iid', Number(iid))
          .limit(1)
          .single();
        if(error){
          const details = JSON.stringify(error, Object.getOwnPropertyNames(error));
          throw new Error(`${error.message} | details: ${details}`);
        }
        renderEditFields(data || {});
        editModal.style.display = 'flex';
      }catch(err){
        console.error('openEdit error:', err);
        modalNotice.style.color = '#a00';
        modalNotice.textContent = 'Failed to load record: ' + (err.message || err);
        // fallback: if we had a row in the table view, user can still edit minimal fields (not implemented here)
      }
    }

    function renderEditFields(record){
      editFields.innerHTML = '';
      // iterate keys in sorted order for predictability
      const keys = Object.keys(record).sort();
      keys.forEach(key => {
        const val = record[key] === null || record[key] === undefined ? '' : record[key];
        const row = document.createElement('div');
        row.className = 'field-row';
        const label = document.createElement('label');
        label.textContent = key + ':';
        // decide input type: use textarea for long text fields (heuristic)
        let input;
        if(String(val).length > 120 || key.toLowerCase().includes('address') || key.toLowerCase().includes('note')){
          input = document.createElement('textarea');
          input.rows = 4;
        } else {
          input = document.createElement('input');
          input.type = 'text';
        }
        input.value = val;
        input.setAttribute('data-field', key);
        if(key === 'IID'){
          input.readOnly = true;
        }
        row.appendChild(label);
        row.appendChild(input);
        editFields.appendChild(row);
      });
    }

    async function saveEdit(){
      modalNotice.textContent = '';
      if(!currentIID){ modalNotice.textContent = 'No record selected'; return; }
      // build payload from inputs
      const inputs = editFields.querySelectorAll('[data-field]');
      const payload = {};
      inputs.forEach(inp =>{
        const field = inp.getAttribute('data-field');
    if(field === 'iid' || field === 'IID') return; // don't try to update primary key
        const v = inp.value === '' ? null : inp.value;
        payload[field] = v;
      });
      saveBtn.disabled = true;
      saveBtn.textContent = 'Saving...';
      try{
        const { data, error } = await supabase
          .from(tableName)
          .update(payload)
          .eq('iid', Number(currentIID));
        if(error){
          const details = JSON.stringify(error, Object.getOwnPropertyNames(error));
          throw new Error(`${error.message} | details: ${details}`);
        }
        modalNotice.style.color = 'green';
        modalNotice.textContent = 'Updated successfully';
  // refresh list and cache and close
  await loadData(false);
        setTimeout(()=>{ closeModal(); modalNotice.textContent = ''; }, 700);
      }catch(err){
        console.error('saveEdit error:', err);
        modalNotice.style.color = '#a00';
        modalNotice.textContent = 'Update error: ' + (err.message || err);
      }finally{
        saveBtn.disabled = false;
        saveBtn.textContent = 'Save';
      }
    }

    function closeModal(){
      editModal.style.display = 'none';
      editFields.innerHTML = '';
      currentIID = null;
    }

    function escapeHtml(s){
      if(s === null || s === undefined) return '';
      return String(s).replace(/[&<>\\"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','\\"':'&quot;',"'":'&#39;'}[c]));
    }

    // close modal when clicking outside panel
    editModal.addEventListener('click', (e)=>{ if(e.target===editModal) closeModal(); });

    // initial load - directly load all data without cache
    (function smartInitial(){
      console.log('Smart initial started');
      console.log('Supabase available:', typeof window.supabase !== 'undefined');
      console.log('Status element:', statusEl);
      // Always load fresh data, no cache check
      loadData(false);
    })();
  </script>
</body>
</html>

