<!doctype html>
<html lang="bn">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>All Data Fields — 0newdatabase</title>
<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
<link rel="preconnect" href="https://docs.google.com" crossorigin>
<link href="https://fonts.maateen.me/kalpurush/font.css" rel="stylesheet">

<style>
:root{ --bg:#f6f7f9; --card:#fff; --muted:#6b7280; --accent:#2196F3; }
*{box-sizing:border-box}
body{margin:0;font-family: 'Noto Sans Bengali','Hind Siliguri', system-ui, Arial, sans-serif;background:var(--bg);color:#111}
.header{position:sticky;top:0;background:var(--card);border-bottom:1px solid #e5e7eb;z-index:10}
.container{max-width:1200px;margin:0 auto;padding:1rem}
h1{margin:.25rem 0;text-align:center}
.toolbar{display:flex;gap:.75rem;align-items:center;justify-content:center;flex-wrap:wrap;margin:.5rem 0 1rem}
input[type=search]{padding:.55rem .8rem;min-width:240px;border:1px solid #d1d5db;border-radius:10px}
.select{padding:.5rem .7rem;border:1px solid #d1d5db;border-radius:10px;background:#fff}
.muted{color:var(--muted);font-size:.9rem}
.group{background:transparent;border:none;border-radius:0;padding:0;margin:1rem 0 0 0;box-shadow:none}
/* full-bleed header band */
.group h2{margin:0;font-size:1.05rem;text-align:left;padding:1rem 1rem;border-radius:0;position:relative;left:50%;right:50%;margin-left:-50vw;margin-right:-50vw;width:100vw}
/* ensure table content stays centered and constrained */
.group .table-wrap{position:relative;left:50%;right:50%;margin-left:-50vw;margin-right:-50vw;width:100vw;padding:0.75rem 1rem}
.group[data-class="6"] h2{background:linear-gradient(90deg,#2196F3,#64b5f6);color:#fff}
.group[data-class="7"] h2{background:linear-gradient(90deg,#2e7d32,#66bb6a);color:#fff}
.group[data-class="8"] h2{background:linear-gradient(90deg,#6a1b9a,#ab47bc);color:#fff}
.group[data-class="9"] h2{background:linear-gradient(90deg,#ef6c00,#ffa726);color:#fff}
.group[data-class="10"] h2{background:linear-gradient(90deg,#c2185b,#ec407a);color:#fff}
/* Table (Google Sheets like) */
.table-wrap{overflow:auto;border-radius:8px;border:1px solid #e8eef8;background:#fff}
table.sheet-table{border-collapse:collapse;width:100%;min-width:720px;font-size:0.5em}
table.sheet-table thead th{position:sticky;top:0;background:linear-gradient(180deg,#f8fafc,#f1f5f9);padding:.55rem .7rem;text-align:left;border-bottom:2px solid #e6eef7}
table.sheet-table th, table.sheet-table td{padding:.5rem .65rem;border-right:1px solid #f1f5f9;border-bottom:1px solid #f6f9fc}
table.sheet-table tbody tr:hover{background:#fbfdff}
table.sheet-table td{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;max-width:260px}
table.sheet-table td:first-child{min-width:160px}
/* small responsive tweak */
@media (max-width:720px){ table.sheet-table td{max-width:160px} }
@media (prefers-color-scheme:dark){ body{background:#071025;color:#e6eef8} .group{background:#07162a;border-color:#183047} .col-box{background:#071827;border-color:#123146} }
.notice{font-size:.9rem;color:#444;text-align:center;margin-top:-6px}
.summary-line{font-size:.95rem;color:#334155;margin:.5rem 0 0}
@media (prefers-color-scheme:dark){ .summary-line{color:#cbd5e1} }

</style>



<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

<script>
// reuse small helpers from datalist
async function loadSheetList(){
  const res = await fetch('sheetidname.text',{cache:'no-store'});
  if(!res.ok) throw new Error('Failed to load sheetidname.text');
  const txt = await res.text();
  const lines = txt.split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
  const pairs=[]; let curId=null;
  const idRe=/^let\s+sheetId\s*=\s*['"]([^'"]+)['"];/i;
  const nameRe=/^let\s+sheetName\s*=\s*['"]([^'"]+)['"];/i;
  for(const line of lines){
    const im = idRe.exec(line); if(im){ curId = im[1]; continue; }
    const nm = nameRe.exec(line); if(nm && curId){ pairs.push({id:curId,name:nm[1]}); curId=null; }
  }
  return pairs;
}
function csvUrl(id, sheet){ return `https://docs.google.com/spreadsheets/d/${encodeURIComponent(id)}/gviz/tq?tqx=out:csv&sheet=${encodeURIComponent(sheet)}`; }
function parseSheetMeta(name){ const m=String(name||'').trim().match(/^(\d{1,2})[\s_\-]?(.+)$/); if(!m) return {}; return { cls: m[1], shift: (m[2]||'').trim() }; }

function slugify(s){
  return 's'+String(s||'').toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/^-+|-+$/g,'');
}

// Fast helpers for header detection and safe HTML
function normHeader(s){ return String(s||'').toLowerCase().replace(/[\s_\-]+/g,'').trim(); }
function findIidKey(fields){
  const order=['iid','id','studentid','sid'];
  const map=new Map(fields.map(f=>[normHeader(f), f]));
  for(const k of order){ if(map.has(k)) return map.get(k); }
  return null;
}
function escapeHtml(v){
  return String(v==null? '': v)
    .replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')
    .replace(/\"/g,'&quot;').replace(/'/g,'&#39;');
}

// Robust CSV loader helpers
const FETCH_TIMEOUT_MS = 12000; // 12s per sheet
const MAX_RETRY = 1;            // retry once on timeout/error

function parseCsvWithTimeout(url, { timeoutMs = FETCH_TIMEOUT_MS } = {}){
  const papaPromise = new Promise((resolve)=>{
    Papa.parse(url, {
      download: true, header: true, skipEmptyLines: true, worker: true,
      complete: r => resolve({ type: 'result', r }),
      error: e => resolve({ type: 'error', e })
    });
  });
  const timeoutPromise = new Promise(resolve => setTimeout(()=> resolve({ type: 'timeout' }), timeoutMs));
  return Promise.race([papaPromise, timeoutPromise]);
}

function createLimiter(limit){
  let active = 0; const queue = [];
  function next(){
    if(active >= limit) return;
    const item = queue.shift(); if(!item) return;
    active++;
    item.fn().then(v=>{ active--; item.resolve(v); next(); }).catch(e=>{ active--; item.reject(e); next(); });
  }
  return function schedule(fn){
    return new Promise((resolve, reject)=>{ queue.push({ fn, resolve, reject }); next(); });
  };
}

function addSheetButton(name, count, targetId){
  // No-op now; replaced by summary table. Keep for backward safety.
}

function scrollToSection(targetId){
  const el = document.getElementById(targetId); if(!el) return;
  const header = document.querySelector('.header');
  const offset = (header? header.offsetHeight: 0) + 8;
  const top = el.getBoundingClientRect().top + window.scrollY - offset;
  window.scrollTo({ top, behavior:'smooth' });
}

// Chunked rendering to keep UI responsive
const INITIAL_ROWS = 60;  // render this many rows immediately (smaller to avoid jank)
const CHUNK_SIZE = 300;   // append this many rows per batch on demand

// Lazy-load observer: auto-append remaining rows when the section comes into view
let lazyObserver = null;
if('IntersectionObserver' in window){
  lazyObserver = new IntersectionObserver((entries)=>{
    for(const e of entries){
      if(e.isIntersecting){
        const sec = e.target;
        const btn = sec.querySelector('button.lazy-load-btn');
        if(btn && !btn.__clicked){ btn.__clicked = true; btn.click(); }
        lazyObserver.unobserve(sec);
      }
    }
  }, { rootMargin: '200px' });
}

function renderSheet(container, name, fields, rows, meta, src){
  const section = document.createElement('section'); section.className='group'; if(meta && meta.cls) section.dataset.class = meta.cls; section.id = slugify(name);
  // Header (no counts)
  const headerHtml = `<h2>${escapeHtml(name)}</h2>`;
  // Skeleton table
  const theadHtml = '<thead><tr>' + fields.map(f=>`<th>${escapeHtml(f)}</th>`).join('') + '</tr></thead>';
  section.innerHTML = headerHtml + `<div class="table-wrap"><table class="sheet-table">${theadHtml}<tbody></tbody></table></div>`;
  container.appendChild(section);

  const tbody = section.querySelector('tbody');
  const allFieldNames = rows[0] ? Object.keys(rows[0]) : fields;
  const iidKey = findIidKey(allFieldNames);

  function rowHtml(rIdx){
    const r = rows[rIdx];
    let html = '<tr>';
    for(let fi=0; fi<fields.length; fi++){
      const f = fields[fi]; const val = (r && Object.prototype.hasOwnProperty.call(r,f)) ? r[f] : '';
      if(fi===0){
        let href = `detailsinfo.html?id=${encodeURIComponent(src.id)}&sheet=${encodeURIComponent(src.name)}`;
        let iidVal = '';
        try{ iidVal = iidKey ? (r[iidKey]) : ''; }catch(_){ iidVal=''; }
        if(iidVal!=null && String(iidVal).trim()!=='') href += `&iid=${encodeURIComponent(String(iidVal))}`; else href += `&r=${rIdx}`;
        const text = (val!=null && String(val).trim()!=='') ? String(val) : `#${rIdx+1}`;
        html += `<td><a class="link" style="color:inherit;text-decoration:none" href="${href}">${escapeHtml(text)}</a></td>`;
      } else {
        html += `<td>${escapeHtml(val)}</td>`;
      }
    }
    html += '</tr>';
    return html;
  }

  function renderRange(start, end){
    let buf = '';
    for(let i=start;i<end;i++) buf += rowHtml(i);
    tbody.insertAdjacentHTML('beforeend', buf);
  }

  // Initial render
  const initialEnd = Math.min(INITIAL_ROWS, rows.length);
  if(initialEnd > 0) renderRange(0, initialEnd);

  // If many rows, provide a lazy load button
  if(rows.length > initialEnd){
    const btn = document.createElement('button');
    btn.textContent = `Load remaining ${rows.length - initialEnd} rows`;
    btn.style.cssText = 'margin:8px 0; padding:6px 10px; border:1px solid #d1d5db; border-radius:8px; background:#fff; cursor:pointer;';
    btn.className = 'lazy-load-btn';
    const wrap = document.createElement('div'); wrap.appendChild(btn);
    section.querySelector('.table-wrap').appendChild(wrap);
    btn.addEventListener('click', ()=>{
      btn.disabled = true; btn.textContent = 'Loading…';
      let next = initialEnd;
      function step(){
        const end = Math.min(next + CHUNK_SIZE, rows.length);
        renderRange(next, end);
        next = end;
        if(next < rows.length){ setTimeout(step, 0); }
        else { btn.remove(); }
      }
      step();
    });
    // Observe section to auto-load when visible
    if(lazyObserver){ lazyObserver.observe(section); }
  }
}

function filterAll(q){ const query=q.toLowerCase(); document.querySelectorAll('table.sheet-table tbody tr').forEach(tr=>{
    const text = tr.textContent.toLowerCase(); tr.style.display = (!query || text.includes(query))? '' : 'none';
  }); }

async function init(){
  const status = document.getElementById('status');
  try{
    status.textContent = 'Loading sheet list…';
    const pairs = await loadSheetList(); if(!pairs.length){ status.textContent='No sheets defined'; return; }
    status.textContent = `Found ${pairs.length} sheets. Fetching…`;
    const host = document.getElementById('host');
    let ok=0,fail=0;
    // Kick off fetches with concurrency limit and per-sheet timeouts
    const limit = createLimiter(4);
    const tasks = pairs.map(({id,name}, idx)=> limit(async ()=>{
      const url = csvUrl(id, name);
      let attempt = 0;
      while(true){
        const outcome = await parseCsvWithTimeout(url, { timeoutMs: FETCH_TIMEOUT_MS });
        if(outcome.type === 'result'){
          const results = outcome.r;
          const rows = (results && results.data)? results.data : [];
          const fields = (results && results.meta && results.meta.fields) ? results.meta.fields : Object.keys(rows[0]||{});
          ok++; status.textContent = `Loaded ${ok}/${pairs.length}` + (fail? `, failed ${fail}` : '');
          return { idx, id, name, rows, fields, meta: parseSheetMeta(name), success:true };
        }
        const err = (outcome.type === 'timeout') ? new Error('Timeout') : (outcome.e || new Error('Parse error'));
        if(attempt < MAX_RETRY){ attempt++; await new Promise(r=>setTimeout(r, 500 + Math.random()*700)); continue; }
        console.error('Fetch error', name, err);
        fail++; status.textContent = `Loaded ${ok}/${pairs.length}, failed ${fail}`;
        return { idx, name, error: err, success:false };
      }
    }));
    const results = await Promise.all(tasks);
    // Render in original order for consistency
    results.sort((a,b)=>a.idx-b.idx);
    const allSheetNames = results.filter(r=>r.success).map(r=>r.name);
    results.forEach(r=>{
      if(r.success){
        renderSheet(host, r.name, r.fields, r.rows, r.meta, { id:r.id, name:r.name });
      }
      else {
        const err=document.createElement('section'); err.className='group'; const h=document.createElement('h2'); h.textContent = r.name+' (failed)'; err.appendChild(h); const pre=document.createElement('pre'); pre.textContent = String(r.error && r.error.message || r.error); err.appendChild(pre); host.appendChild(err);
      }
    });
    // Populate filter dropdown
    const sheetSel = document.getElementById('sheetFilter');
    sheetSel.innerHTML = '<option value="">সব ক্লাস/শিট</option>' + allSheetNames.map(n=>`<option value="${slugify(n)}">${escapeHtml(n)}</option>`).join('');
    sheetSel.addEventListener('change', ()=>{
      const val = sheetSel.value;
      document.querySelectorAll('.group').forEach(sec=>{
        if(!val || sec.id === val) sec.style.display = '';
        else sec.style.display = 'none';
      });
    });
    // Summary tables removed
    status.classList.add('ok');
  }catch(err){ console.error(err); status.textContent='Init failed'; status.classList.add('error'); }
}

window.addEventListener('DOMContentLoaded', ()=>{ init(); const s=document.getElementById('search'); s.addEventListener('input', ()=>filterAll(s.value)); });
</script>


</head>
<body>
<header class="header">
  <div class="container">
    <h1>All Data Fields</h1>
    <div class="toolbar">
      <select id="sheetFilter" style="padding:.5rem .7rem;border:1px solid #d1d5db;border-radius:10px;background:#fff;min-width:180px;">
        <option value="">সব ক্লাস/শিট</option>
      </select>
      <input id="search" type="search" placeholder="Search column name or value…" aria-label="Filter" />
      <span id="status" class="muted"></span>
    </div>
  
  <div class="notice">ক্লাস অনুযায়ী ডাটা টেবিলগুলো দেখানো হয়েছে।</div>
  </div>
</header>
<main class="container">
  <div id="host"></div>
</main>
</body>

</html>
