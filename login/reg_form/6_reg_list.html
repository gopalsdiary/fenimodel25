<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link href="https://fonts.googleapis.com/css2?family=Kalpurush&display=swap" rel="stylesheet">
  <title>Entry - Show & Edit</title>
  <style>
    /* reduce base font size by 20% and use Kalpurush font */
    html {
      font-size: 80%;
    }

    body {
      font-family: 'Kalpurush', Arial, Helvetica, sans-serif;
      padding: 16px
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 12px;
      table-layout: auto
    }

    th,
    td {
      border: 1px solid #ddd;
      padding: 8px;
      text-align: left;
      vertical-align: middle;
      white-space: nowrap
    }

    th {
      background: #f4f4f4
    }

    /* zebra striping */
    tbody tr:nth-child(odd) {
      background: #ffffff
    }

    tbody tr:nth-child(even) {
      background: #f5f5f5
    }

    .btn {
      padding: 6px 10px;
      border: none;
      background: #0b74de;
      color: #fff;
      border-radius: 4px;
      cursor: pointer
    }

    .btn.secondary {
      background: #6c757d
    }

    .btn.updated {
      background: #28a745 !important;
      cursor: default !important
    }

    .row-update-status {
      font-weight: 600;
      font-size: 13px;
      margin-left: 8px
    }

    .btn.bulk {
      background: #ff6b35 !important;
      font-weight: bold !important
    }

    /* modal */
    .modal {
      position: fixed;
      left: 0;
      top: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      display: none;
      align-items: center;
      justify-content: center
    }

    .modal .panel {
      background: #fff;
      padding: 16px;
      border-radius: 6px;
      max-width: 720px;
      width: 100%;
      max-height: 80vh;
      overflow: auto
    }

    .field-row {
      display: flex;
      gap: 8px;
      margin-bottom: 8px;
      align-items: center
    }

    .field-row label {
      min-width: 140px
    }

    .field-row input,
    .field-row textarea {
      flex: 1;
      padding: 8px
    }

    .notice {
      margin-top: 8px;
      color: #a00
    }

    .error-details {
      font-family: monospace;
      font-size: 12px;
      color: #900;
      margin-top: 6px
    }

    /* status column */
    /* ensure TC rows override zebra */
    tbody tr.status-tc {
      background-color: rgba(250, 187, 187, 0.5) !important
    }

    /* SL (serial) column small */
    .col-sl {
      width: 56px;
      max-width: 56px;
      padding: 4px;
      text-align: center
    }
  </style>
</head>

<body>
  <h2>Active Students 2026</h2>
  <div>
    <!-- Class, Section Filters -->
    <select id="filterClass" style="padding:6px; margin-right:8px;">
      <option value="">Select Class</option>
    </select>
    <select id="filterSection" style="padding:6px; margin-right:8px;">
      <option value="">All Sections</option>
    </select>

    <button id="allRegFormBtn" class="btn" style="background:#28a745; margin-right:8px;">All Reg Form 6</button>
    <span id="status" style="margin-left:12px;color:#444"></span>
    <!-- Pagination controls -->
    <span style="margin-left:18px;">
      <button id="prevPage" class="btn secondary">Prev</button>
      <span id="pageInfo" style="margin:0 8px;">Page 1</span>
      <button id="nextPage" class="btn">Next</button>
    </span>
  </div>

  <table id="dataTable">
    <thead>
      <tr>
        <!-- Headers will be dynamically generated -->
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Loading...</td>
      </tr>
    </tbody>
  </table>

  <!-- Edit modal -->
  <div id="editModal" class="modal">
    <div class="panel">
      <h3>Edit Record</h3>

      <!-- Dynamic fields will be rendered here -->
      <div id="editFields"></div>

      <div style="text-align:right;margin-top:12px">
        <button id="cancelBtn" class="btn secondary">Cancel</button>
        <button id="saveBtn" class="btn">Save</button>
      </div>
      <div id="modalNotice" class="notice"></div>
    </div>
  </div>

  <!-- Supabase client -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <!-- Auth check -->
  <script src="../auth-check_copy.js"></script>
  <script>

    // Use the same project URL used elsewhere in this repo
    const supabaseUrl = 'https://rtfefxghfbtirfnlbucb.supabase.co';
    // For security, set supabaseKey via window.SUPABASE_ANON_KEY or input
    const supabaseKey = window.SUPABASE_ANON_KEY || 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJ0ZmVmeGdoZmJ0aXJmbmxidWNiIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDA1MDg3OTcsImV4cCI6MjA1NjA4NDc5N30.fb7_myCmFzbV7WPNjFN_NEl4z0sOmRCefnkQbk6c10w';
    // Reuse existing Supabase client or create new one
    if (!window.supabaseClient) {
      window.__supabaseClients = window.__supabaseClients || {};
      window.supabaseClient = window.__supabaseClients[supabaseUrl] || window.supabase.createClient(supabaseUrl, supabaseKey);
      window.__supabaseClients[supabaseUrl] = window.supabaseClient;
    }
    const supabaseClient = window.supabaseClient;

    const tableName = 'student_database';
    // Simple 10-minute TTL cache (localStorage) with SWR behavior

    const tbody = document.querySelector('#dataTable tbody');
    const statusEl = document.getElementById('status');
    const prevPageBtn = document.getElementById('prevPage');
    const nextPageBtn = document.getElementById('nextPage');
    const pageInfo = document.getElementById('pageInfo');
    const filterClass = document.getElementById('filterClass');
    const filterSection = document.getElementById('filterSection');
    const allRegFormBtn = document.getElementById('allRegFormBtn');

    // keep full dataset in memory for client-side pagination
    let allRowsCache = [];
    const PAGE_SIZE = 500; // show first 500 in page 1
    let currentPage = 1;
    let loadingInProgress = false;

    // modal elems
    const editModal = document.getElementById('editModal');
    const editFields = document.getElementById('editFields');
    const cancelBtn = document.getElementById('cancelBtn');
    const saveBtn = document.getElementById('saveBtn');
    const modalNotice = document.getElementById('modalNotice');

    // Check if required elements exist
    if (!tbody || !statusEl) {
      console.error('Required DOM elements not found!');
      console.log('tbody:', tbody, 'statusEl:', statusEl);
    }

    // Refresh and filter controls removed per request
    cancelBtn.addEventListener('click', closeModal);
    saveBtn.addEventListener('click', saveEdit);
    filterClass.addEventListener('change', () => renderPage(1));
    filterSection.addEventListener('change', () => renderPage(1));
    allRegFormBtn.addEventListener('click', generateAllRegForms);

    // store the currently editing IID
    let currentIID = null;

    // ---- Cache helpers ----
    function saveCache(rows) {
      try {
        const payload = { ts: Date.now(), rows };
        localStorage.setItem(CACHE_KEY, JSON.stringify(payload));
      } catch (e) { /* ignore quota or serialization issues */ }
    }

    function loadCache() {
      try {
        const raw = localStorage.getItem(CACHE_KEY);
        if (!raw) return null;
        const obj = JSON.parse(raw);
        if (!obj || !Array.isArray(obj.rows) || typeof obj.ts !== 'number') return null;
        return obj;
      } catch (e) { return null; }
    }

    function showFromCacheIfFresh() {
      const cached = loadCache();
      if (!cached) return false;
      const age = Date.now() - cached.ts;
      if (age > CACHE_TTL_MS) return false;
      allRowsCache = cached.rows;
      updateFilterOptions();
      renderPage(1);
      const mins = Math.max(0, Math.floor(age / 60000));
      statusEl.textContent = `Total: ${allRowsCache.length} (from cache, ${mins}m old)`;
      // Kick off a background refresh (SWR) without blocking UI
      setTimeout(() => { loadData(true /*background*/); }, 0);
      return true;
    }



    async function loadData(background = false) {
      console.log('loadData started, background:', background);
      loadingInProgress = true;
      try { tbody.innerHTML = ''; } catch (e) { }
      if (!background) statusEl.textContent = 'Loading data...';
      try {
        let allData = [];
        let lastId = 0;
        let batchSize = 1000;
        let hasMore = true;
        let batchCount = 0;
        let prevLastId = null;
        const maxBatches = 10000;

        if (!background) {
          batchCount++;
          console.log(`Initial foreground load`);
          statusEl.textContent = `Loading initial data...`;

          let data, error;
          try {
            ({ data, error } = await supabaseClient
              .from(tableName)
              .select('*')
              .order('iid', { ascending: true })
              .limit(PAGE_SIZE));
          } catch (e) { error = e; }

          if (error) throw new Error(error.message || 'Error fetching data');

          if (!data || data.length === 0) {
            hasMore = false;
          } else {
            allData = data;
            lastId = data[data.length - 1].iid;
            prevLastId = lastId;
            hasMore = data.length === PAGE_SIZE;
          }

          allRowsCache = allData;
          updateFilterOptions();
          renderPage(1); // will apply dropdown filters

          if (hasMore) {
            setTimeout(() => { loadData(true); }, 50);
          } else {
            statusEl.textContent = `✅ Loaded ${allRowsCache.length} records`;
            saveCache(allRowsCache);
          }
          return;
        }

        // Background
        if (background && allRowsCache.length > 0) {
          lastId = Number(allRowsCache[allRowsCache.length - 1].iid) || lastId;
        }

        while (hasMore && batchCount < maxBatches) {
          batchCount++;
          statusEl.textContent = `Loading... (${allRowsCache.length} records)`;

          const { data, error } = await supabaseClient
            .from(tableName)
            .select('*')
            .gt('iid', lastId)
            .order('iid', { ascending: true })
            .limit(batchSize);

          if (error) { console.error(error); break; }
          if (!data || data.length === 0) { hasMore = false; break; }

          for (const row of data) allRowsCache.push(row);
          lastId = data[data.length - 1].iid;

          if (prevLastId !== null && Number(lastId) === Number(prevLastId)) break;
          prevLastId = lastId;

          pageInfo.textContent = `Page ${currentPage} / ...`;
        }

        updateFilterOptions();
        statusEl.textContent = `✅ Total: ${allRowsCache.length} records loaded`;
        saveCache(allRowsCache);
        renderPage(currentPage); // update view

      } catch (err) {
        console.error('loadData error:', err);
        statusEl.textContent = 'Error: ' + err.message;
      } finally {
        loadingInProgress = false;
      }
    }

    // Filter helpers removed per request

    function updateFilterOptions() {
      const classValues = new Set();
      const sectionValues = new Set();

      allRowsCache.forEach(r => {
        const cls = r.class_2026;
        const sec = r.section_2026;
        if (cls !== null && cls !== undefined && String(cls).trim() !== '') {
          classValues.add(String(cls).trim());
        }
        if (sec !== null && sec !== undefined && String(sec).trim() !== '') {
          sectionValues.add(String(sec).trim());
        }
      });

      const classList = Array.from(classValues).sort((a, b) => {
        const na = Number(a), nb = Number(b);
        if (!Number.isNaN(na) && !Number.isNaN(nb)) return na - nb;
        return a.localeCompare(b);
      });
      const sectionList = Array.from(sectionValues).sort((a, b) => a.localeCompare(b));

      // Preserve selection if possible
      const currentClass = filterClass.value;

      filterClass.innerHTML = '<option value="">Select Class</option>';
      classList.forEach(v => {
        const opt = document.createElement('option');
        opt.value = v;
        opt.textContent = v;
        if (v === currentClass) opt.selected = true;
        filterClass.appendChild(opt);
      });

      filterSection.innerHTML = '<option value="">All Sections</option>';
      sectionList.forEach(v => {
        const opt = document.createElement('option');
        opt.value = v;
        opt.textContent = v;
        filterSection.appendChild(opt);
      });
    }

    // Function to check existing active_section data
    async function getExistingActiveSectionData(iids) {
      try {
        const { data, error } = await supabaseClient
          .from('active_section')
          .select('iid, active_class, active_section, active_roll, session, student_name_en, student_key')
          .in('iid', iids);

        if (error) {
          console.error('Error fetching existing active_section data:', error);
          return {};
        }

        // Convert array to object with iid as key for easy lookup
        const existingData = {};
        data.forEach(row => {
          existingData[row.iid] = row;
        });

        return existingData;
      } catch (err) {
        console.error('getExistingActiveSectionData error:', err);
        return {};
      }
    }

    async function updateActiveSection(row, btnEl) {
      try {
        // Get the dynamic values for active columns
        const session = row['session'];
        const activeClass = session ? row[`class_${session}`] : '';
        const activeSection = session ? row[`section_${session}`] : '';
        const activeRoll = session ? row[`roll_${session}`] : '';

        // Prepare data to save to active_section table
        // derive student_key from father_mobile (last 6 digits)
        const fmRaw = row['father_mobile'] || '';
        const fmDigits = String(fmRaw).replace(/\D/g, '');
        const studentKey = fmDigits.length > 6 ? fmDigits.slice(-6) : (fmDigits || null);

        const dataToSave = {
          iid: row['iid'],
          active_roll: activeRoll || null,
          active_section: activeSection || null,
          active_class: activeClass || null,
          session: row['session'] || null,
          student_name_en: row['student_name_en'] || null,
          student_key: studentKey
        };

        console.log('Saving to active_section table:', dataToSave);

        // Insert or update in active_section table
        const { data, error } = await supabaseClient
          .from('active_section')
          .upsert(dataToSave, { onConflict: 'iid' });

        if (error) {
          console.error('Error saving to active_section:', error);
          // Show inline error next to button if available
          if (btnEl) {
            const s = btnEl.nextElementSibling; // statusSpan
            if (s) { s.textContent = 'Error'; s.style.color = '#a00'; }
          } else {
            alert('Error updating active section: ' + error.message);
          }
        } else {
          console.log('Successfully saved to active_section:', data);
          // Update the UI inline: mark button as Updated and show green text
          if (btnEl) {
            btnEl.className = 'btn updated';
            btnEl.innerHTML = '✓ Updated';
            btnEl.style.backgroundColor = '#28a745';
            btnEl.style.color = '#fff';
            btnEl.disabled = true;
            const s = btnEl.nextElementSibling; // statusSpan
            if (s) { s.textContent = 'Updated'; s.style.color = '#28a745'; }
          }
          // Refresh the table status indicators (keeps current page)
          renderPage(currentPage);
        }
      } catch (err) {
        console.error('updateActiveSection error:', err);
        if (btnEl) {
          const s = btnEl.nextElementSibling;
          if (s) { s.textContent = 'Error'; s.style.color = '#a00'; }
        } else {
          alert('Error: ' + err.message);
        }
      }
    }

    async function renderTable(rows) {
      if (!rows || rows.length === 0) {
        const thead = document.querySelector('#dataTable thead');
        // requested columns
        const keysEmpty = ['iid', 'session', 'student_name_en', 'father_mobile', 'class_2026', 'section_2026', 'roll_2026'];
        thead.innerHTML = '<tr><th class="col-sl">SL</th>' + keysEmpty.map(k => `<th>${escapeHtml(k)}</th>`).join('') + '<th>Action</th></tr>';
        tbody.innerHTML = `<tr><td colspan="${keysEmpty.length + 2}">No records found</td></tr>`;
        return;
      }

      // Get all iids to check existing data
      const iids = rows.map(r => r.iid);
      const existingData = await getExistingActiveSectionData(iids);

      // Fixed keys for selected columns as requested: iid, session, name, father_mobile, class_2026, sec_2026, rol_2026
      const keys = ['iid', 'session', 'student_name_en', 'father_mobile', 'class_2026', 'section_2026', 'roll_2026'];

      // Render header with SL column and Action button
      const thead = document.querySelector('#dataTable thead');
      thead.innerHTML = '<tr><th class="col-sl">SL</th>' + keys.map(k => `<th>${escapeHtml(k)}</th>`).join('') + '<th>Action</th></tr>';

      // Render body
      tbody.innerHTML = '';
      const colCount = keys.length + 2; // +1 for SL column, +1 for Update column

      rows.forEach((r, index) => {
        const tr = document.createElement('tr');

        // Add SL column first
        const slTd = document.createElement('td');
        slTd.className = 'col-sl';
        slTd.textContent = index + 1;
        tr.appendChild(slTd);

        keys.forEach(k => {
          const td = document.createElement('td');
          let val;

          // Handle dynamic active columns based on session
          if (k === 'active_class') {
            const session = r['session'];
            const dynamicKey = session ? `class_${session}` : '';
            val = dynamicKey && r[dynamicKey] !== null && r[dynamicKey] !== undefined ? String(r[dynamicKey]) : '';
          } else if (k === 'active_section') {
            const session = r['session'];
            const dynamicKey = session ? `section_${session}` : '';
            val = dynamicKey && r[dynamicKey] !== null && r[dynamicKey] !== undefined ? String(r[dynamicKey]) : '';
          } else if (k === 'active_roll') {
            const session = r['session'];
            const dynamicKey = session ? `roll_${session}` : '';
            val = dynamicKey && r[dynamicKey] !== null && r[dynamicKey] !== undefined ? String(r[dynamicKey]) : '';
          } else if (k === 'student_key') {
            // derive student_key: last 6 digits of father_mobile (digits only)
            const fmRaw = r['father_mobile'] || '';
            const fmDigits = String(fmRaw).replace(/\D/g, '');
            val = fmDigits.length > 6 ? fmDigits.slice(-6) : fmDigits;
          } else {
            val = r[k] === null || r[k] === undefined ? '' : String(r[k]);
          }

          td.textContent = escapeHtml(val);
          tr.appendChild(td);
        });

        // Add Reg Form button in Action column
        const actionTd = document.createElement('td');
        const regFormBtn = document.createElement('button');
        regFormBtn.className = 'btn';
        regFormBtn.textContent = 'Reg Form 6';

        // Navigate to registration form with iid parameter
        regFormBtn.addEventListener('click', () => {
          window.location.href = `6_reg_form.html?iid=${r.iid}`;
        });

        actionTd.appendChild(regFormBtn);
        tr.appendChild(actionTd);

        tbody.appendChild(tr);
      });

      // All rows rendered into tbody above.
      console.log('renderTable completed, rows rendered:', rows.length);
    }

    // Render a specific page (sliced rows)
    function renderPage(page) {
      currentPage = Math.max(1, Number(page) || 1);

      // Filter logic
      const fClass = filterClass.value;
      const fSection = filterSection.value;

      // If no class selected, show empty table
      if (!fClass) {
        renderTable([]);
        pageInfo.textContent = 'Please select a Class';
        prevPageBtn.disabled = true;
        nextPageBtn.disabled = true;
        return;
      }
      const filtered = allRowsCache.filter(r => {
        if (fClass && String(r.class_2026) !== fClass) return false;
        if (fSection && String(r.section_2026) !== fSection) return false;
        return true;
      });

      const total = filtered.length || 0;
      const totalPages = Math.max(1, Math.ceil(total / PAGE_SIZE));
      if (currentPage > totalPages) currentPage = totalPages;
      const start = (currentPage - 1) * PAGE_SIZE;
      const pageRows = filtered.slice(start, start + PAGE_SIZE);
      renderTable(pageRows);
      pageInfo.textContent = `Page ${currentPage} / ${totalPages} (Total: ${total})`;
      prevPageBtn.disabled = currentPage <= 1;
      nextPageBtn.disabled = currentPage >= totalPages && !loadingInProgress;
    }

    // Generate all registration forms for filtered students
    async function generateAllRegForms() {
      // Get filtered students
      const fClass = filterClass.value;
      const fSection = filterSection.value;
      const filtered = allRowsCache.filter(r => {
        if (fClass && String(r.class_2026) !== fClass) return false;
        if (fSection && String(r.section_2026) !== fSection) return false;
        return true;
      });

      if (filtered.length === 0) {
        alert('No students to generate forms for. Please select class/section.');
        return;
      }

      if (filtered.length > 100) {
        if (!confirm(`This will generate ${filtered.length} registration forms. This may take some time. Continue?`)) {
          return;
        }
      }

      statusEl.textContent = `Generating ${filtered.length} registration forms...`;
      allRegFormBtn.disabled = true;

      // Open a new window for the bulk forms
      const newWindow = window.open('', '_blank');
      if (!newWindow) {
        alert('Please allow pop-ups for this site to generate forms.');
        allRegFormBtn.disabled = false;
        statusEl.textContent = '';
        return;
      }

      // Start building the HTML content
      newWindow.document.write('<!DOCTYPE html><' + 'html><' + 'head><' + 'meta charset="UTF-8"><' + 'title>Bulk Registration Forms</' + 'title>');
      newWindow.document.write('<' + 'style>@page { size: legal portrait; margin: 8mm 10mm; } body { margin: 0; padding: 0; } .page-break { page-break-after: always; }</' + 'style>');
      newWindow.document.write('<' + '/head><' + 'body><' + 'p style="text-align:center; padding:20px;">Loading registration forms...</' + 'p><' + '/body><' + '/html>');

      // Fetch the template from 6_reg_form.html
      try {
        const response = await fetch('6_reg_form.html');
        const templateHtml = await response.text();

        // Extract the template body content
        // Use hex escape for angle brackets to avoid confusion
        const bodyRegex = new RegExp('\\x3Cbody[^>]*>([\\s\\S]*)\\x3C\\/body>', 'i');
        const styleRegex = new RegExp('\\x3Cstyle[^>]*>([\\s\\S]*?)\\x3C\\/style>', 'gi');

        const bodyMatch = templateHtml.match(bodyRegex);
        const styleMatch = templateHtml.match(styleRegex);

        if (!bodyMatch) {
          throw new Error('Could not parse template');
        }

        const templateBody = bodyMatch[1];
        const styles = styleMatch ? styleMatch.join('\n') : '';

        // Clear the loading message and write the actual content
        newWindow.document.open();
        newWindow.document.write('<' + '!DOCTYPE html><' + 'html><' + 'head><' + 'meta charset="UTF-8">');
        newWindow.document.write('<' + 'title>Bulk Registration Forms - ' + (fClass ? 'Class ' + fClass : 'All Classes') + (fSection ? ' Section ' + fSection : '') + '</' + 'title>');
        newWindow.document.write(styles);
        // Add page break CSS
        newWindow.document.write('<' + 'style>');
        newWindow.document.write('@page { size: legal portrait; margin: 8mm 10mm; }');
        newWindow.document.write('body { margin: 0; padding: 0; }');
        newWindow.document.write('.page-container { page-break-inside: avoid; }');
        newWindow.document.write('.page-break { page-break-after: always; break-after: page; }');
        newWindow.document.write('@media print { .page-break { page-break-after: always !important; break-after: page !important; } }');
        newWindow.document.write('.print-footer { display: none !important; }');
        newWindow.document.write('.signature-section { margin-top: 80px !important; }');
        newWindow.document.write('</' + 'style>');
        newWindow.document.write('</' + 'head><' + 'body>');

        // Generate a form for each student
        for (let i = 0; i < filtered.length; i++) {
          const student = filtered[i];
          let formHtml = templateBody;

          // Replace all placeholders with actual data
          const fields = [
            'class_2026', 'section_2026', 'session', 'roll_2026',
            'student_name_en', 'student_name_bn', 'birth_registration', 'religion',
            'student_dateofbirth', 'previous_school',
            'father_mobile', 'father_name_en', 'father_name_bn', 'father_nid',
            'father_dob', 'father_occupation',
            'mother_name_en', 'mother_name_bn', 'mother_nid', 'mother_dob',
            'mother_mobile', 'mother_occupation',
            'village_en', 'village_bn', 'postoffice_en', 'postoffice_bn',
            'upazilla_en', 'upazilla_bn', 'district_en', 'district_bn'
          ];

          fields.forEach(field => {
            const value = student[field] || '';
            // Replace both id="field" content and #field placeholders
            const idPattern = new RegExp('id="' + field + '"[^>]*>#[^<]*', 'g');
            const placeholderPattern = new RegExp('#' + field, 'g');
            formHtml = formHtml.replace(idPattern, 'id="' + field + '_' + i + '">' + value);
            formHtml = formHtml.replace(placeholderPattern, value);
          });

          // Handle special cases
          formHtml = formHtml.replace(/id="father_mobile_sms"[^>]*>#[^<]*/, 'id="father_mobile_sms_' + i + '">' + (student.father_mobile || ''));

          // Permanent address (copy from present)
          const permFields = {
            'village_en_perm': 'village_en',
            'village_bn_perm': 'village_bn',
            'postoffice_en_perm': 'postoffice_en',
            'postoffice_bn_perm': 'postoffice_bn',
            'upazilla_en_perm': 'upazilla_en',
            'upazilla_bn_perm': 'upazilla_bn',
            'district_en_perm': 'district_en',
            'district_bn_perm': 'district_bn'
          };

          Object.keys(permFields).forEach(permField => {
            const baseField = permFields[permField];
            const value = student[baseField] || '';
            const permPattern = new RegExp('id="' + permField + '"[^>]*>#[^<]*', 'g');
            formHtml = formHtml.replace(permPattern, 'id="' + permField + '_' + i + '">' + value);
          });

          // Remove the print button and scripts from individual forms
          formHtml = formHtml.replace(new RegExp('<' + 'div class="no-print"[\\s\\S]*?</' + 'div>', 'g'), '');
          formHtml = formHtml.replace(new RegExp('<' + 'script[\\s\\S]*?</' + 'script>', 'g'), '');

          // Wrap each form in a page container for proper page breaks
          var pageClass = (i < filtered.length - 1) ? 'page-container page-break' : 'page-container';
          newWindow.document.write('<' + 'div class="' + pageClass + '">');
          newWindow.document.write(formHtml);
          newWindow.document.write('</' + 'div>');
        }

        newWindow.document.write('<' + '/body><' + '/html>');
        newWindow.document.close();

        statusEl.textContent = `✅ Generated ${filtered.length} registration forms`;
        allRegFormBtn.disabled = false;

        // Auto-print after a short delay
        setTimeout(() => {
          newWindow.print();
        }, 1000);

      } catch (error) {
        console.error('Error generating forms:', error);
        alert('Error generating forms: ' + error.message);
        newWindow.close();
        statusEl.textContent = 'Error generating forms';
        allRegFormBtn.disabled = false;
      }
    }

    prevPageBtn.addEventListener('click', () => {
      if (currentPage > 1) { renderPage(currentPage - 1); }
    });
    nextPageBtn.addEventListener('click', async () => {
      const total = allRowsCache.length || 0;
      const totalPages = Math.max(1, Math.ceil(total / PAGE_SIZE));
      if (currentPage < totalPages) { renderPage(currentPage + 1); return; }
      // If we're at last loaded page but more data may exist, trigger background fetch
      // Try to trigger background load then wait for at most 5s for new page
      if (!loadingInProgress) {
        console.log('Requesting more data for next page...');
        loadData(true);
      }
      const startWait = Date.now();
      const waitTimeout = 5000; // ms
      while (Date.now() - startWait < waitTimeout) {
        const newTotal = allRowsCache.length || 0;
        const newTotalPages = Math.max(1, Math.ceil(newTotal / PAGE_SIZE));
        if (newTotalPages > totalPages) {
          renderPage(currentPage + 1);
          return;
        }
        // short sleep
        await new Promise(r => setTimeout(r, 250));
      }
      // Timeout - inform user
      alert('Still loading the next page. Please wait a moment and click Next again.');
    });

    async function openEditByIID(iid) {
      // fetch full row from DB to ensure we have all columns
      modalNotice.textContent = '';
      currentIID = iid;
      try {
        const { data, error } = await supabaseClient
          .from(tableName)
          .select('*')
          .eq('iid', Number(iid))
          .limit(1)
          .single();
        if (error) {
          const details = JSON.stringify(error, Object.getOwnPropertyNames(error));
          throw new Error(`${error.message} | details: ${details}`);
        }
        renderEditFields(data || {});
        editModal.style.display = 'flex';
      } catch (err) {
        console.error('openEdit error:', err);
        modalNotice.style.color = '#a00';
        modalNotice.textContent = 'Failed to load record: ' + (err.message || err);
        // fallback: if we had a row in the table view, user can still edit minimal fields (not implemented here)
      }
    }

    function renderEditFields(record) {
      editFields.innerHTML = '';
      // iterate keys in sorted order for predictability
      const keys = Object.keys(record).sort();
      keys.forEach(key => {
        const val = record[key] === null || record[key] === undefined ? '' : record[key];
        const row = document.createElement('div');
        row.className = 'field-row';
        const label = document.createElement('label');
        label.textContent = key + ':';
        // decide input type: use textarea for long text fields (heuristic)
        let input;
        if (String(val).length > 120 || key.toLowerCase().includes('address') || key.toLowerCase().includes('note')) {
          input = document.createElement('textarea');
          input.rows = 4;
        } else {
          input = document.createElement('input');
          input.type = 'text';
        }
        input.value = val;
        input.setAttribute('data-field', key);
        if (key === 'IID') {
          input.readOnly = true;
        }
        row.appendChild(label);
        row.appendChild(input);
        editFields.appendChild(row);
      });
    }

    async function saveEdit() {
      modalNotice.textContent = '';
      if (!currentIID) { modalNotice.textContent = 'No record selected'; return; }
      // build payload from inputs
      const inputs = editFields.querySelectorAll('[data-field]');
      const payload = {};
      inputs.forEach(inp => {
        const field = inp.getAttribute('data-field');
        if (field === 'iid' || field === 'IID') return; // don't try to update primary key
        const v = inp.value === '' ? null : inp.value;
        payload[field] = v;
      });
      saveBtn.disabled = true;
      saveBtn.textContent = 'Saving...';
      try {
        const { data, error } = await supabaseClient
          .from(tableName)
          .update(payload)
          .eq('iid', Number(currentIID));
        if (error) {
          const details = JSON.stringify(error, Object.getOwnPropertyNames(error));
          throw new Error(`${error.message} | details: ${details}`);
        }
        modalNotice.style.color = 'green';
        modalNotice.textContent = 'Updated successfully';
        // refresh list and cache and close
        await loadData(false);
        setTimeout(() => { closeModal(); modalNotice.textContent = ''; }, 700);
      } catch (err) {
        console.error('saveEdit error:', err);
        modalNotice.style.color = '#a00';
        modalNotice.textContent = 'Update error: ' + (err.message || err);
      } finally {
        saveBtn.disabled = false;
        saveBtn.textContent = 'Save';
      }
    }

    function closeModal() {
      editModal.style.display = 'none';
      editFields.innerHTML = '';
      currentIID = null;
    }

    // Bulk update function to update only the currently visible page's records
    async function bulkUpdateActiveSection() {
      if (!allRowsCache || allRowsCache.length === 0) {
        alert('No data loaded. Please load students first.');
        return;
      }

      const bulkUpdateBtn = document.getElementById('bulkUpdateBtn');
      const originalText = bulkUpdateBtn.textContent;

      try {
        bulkUpdateBtn.disabled = true;
        bulkUpdateBtn.textContent = 'Checking...';
        bulkUpdateBtn.style.backgroundColor = '#ffa500';

        // Determine visible page rows only
        const start = (currentPage - 1) * PAGE_SIZE;
        const pageRows = allRowsCache.slice(start, start + PAGE_SIZE);
        if (!pageRows || pageRows.length === 0) {
          alert('No rows visible on this page to update.');
          bulkUpdateBtn.textContent = originalText;
          bulkUpdateBtn.disabled = false;
          bulkUpdateBtn.style.backgroundColor = '';
          return;
        }

        // Get existing data for visible rows only
        const pageIids = pageRows.map(r => r.iid);
        const existingData = await getExistingActiveSectionData(pageIids);

        // Find visible records that need updating
        const recordsToUpdate = [];
        pageRows.forEach(row => {
          const existing = existingData[row.iid];
          const session = row['session'];
          const currentActiveClass = session ? row[`class_${session}`] : '';
          const currentActiveSection = session ? row[`section_${session}`] : '';
          const currentActiveRoll = session ? row[`roll_${session}`] : '';

          const rowStudentKey = (String(row['father_mobile'] || '').replace(/\D/g, '').slice(-6)) || null;
          const isUpdated = existing &&
            existing.active_class === (currentActiveClass || null) &&
            existing.active_section === (currentActiveSection || null) &&
            existing.active_roll === (currentActiveRoll || null) &&
            existing.session === (row['session'] || null) &&
            existing.student_name_en === (row['student_name_en'] || null) &&
            existing.student_key === rowStudentKey;

          if (!isUpdated) recordsToUpdate.push(row);
        });

        if (recordsToUpdate.length === 0) {
          alert('All visible rows are already updated!');
          bulkUpdateBtn.textContent = originalText;
          bulkUpdateBtn.disabled = false;
          bulkUpdateBtn.style.backgroundColor = '';
          return;
        }

        const confirmMsg = `Found ${recordsToUpdate.length} visible records that need updating. Proceed?`;
        if (!confirm(confirmMsg)) {
          bulkUpdateBtn.textContent = originalText;
          bulkUpdateBtn.disabled = false;
          bulkUpdateBtn.style.backgroundColor = '';
          return;
        }

        bulkUpdateBtn.textContent = `Updating visible rows... (0/${recordsToUpdate.length})`;
        bulkUpdateBtn.style.backgroundColor = '#ff6b35';

        let successCount = 0;
        let errorCount = 0;

        // Helper to find the update button element for a given iid in the current table
        function findButtonForIid(iid) {
          try {
            const rows = Array.from(tbody.querySelectorAll('tr'));
            for (const tr of rows) {
              const iidCell = tr.querySelector('td:nth-child(2)');
              if (iidCell && iidCell.textContent.trim() === String(iid)) {
                const btn = tr.querySelector('button');
                const status = tr.querySelector('.row-update-status');
                return { btn, status };
              }
            }
          } catch (e) {/* ignore */ }
          return { btn: null, status: null };
        }

        // Update records in batches
        const batchSize = 50;
        for (let i = 0; i < recordsToUpdate.length; i += batchSize) {
          const batch = recordsToUpdate.slice(i, i + batchSize);
          bulkUpdateBtn.textContent = `Updating visible rows... (${Math.min(i + batchSize, recordsToUpdate.length)}/${recordsToUpdate.length})`;

          const promises = batch.map(async (row) => {
            try {
              const session = row['session'];
              const activeClass = session ? row[`class_${session}`] : '';
              const activeSection = session ? row[`section_${session}`] : '';
              const activeRoll = session ? row[`roll_${session}`] : '';

              const dataToSave = {
                iid: row['iid'],
                active_roll: activeRoll || null,
                active_section: activeSection || null,
                active_class: activeClass || null,
                session: row['session'] || null,
                student_name_en: row['student_name_en'] || null,
                student_key: (function () { const fm = String(row['father_mobile'] || '').replace(/\D/g, ''); return fm.length > 6 ? fm.slice(-6) : (fm || null); })()
              };

              const { error } = await supabaseClient
                .from('active_section')
                .upsert(dataToSave, { onConflict: 'iid' });

              const { btn, status } = findButtonForIid(row.iid);

              if (error) {
                console.error('Bulk update error for iid', row.iid, ':', error);
                errorCount++;
                if (status) { status.textContent = 'Error'; status.style.color = '#a00'; }
              } else {
                successCount++;
                if (btn) {
                  btn.className = 'btn updated';
                  btn.innerHTML = '✓ Updated';
                  btn.style.backgroundColor = '#28a745';
                  btn.style.color = '#fff';
                  btn.disabled = true;
                }
                if (status) { status.textContent = 'Updated'; status.style.color = '#28a745'; }
              }
            } catch (err) {
              console.error('Bulk update exception for iid', row.iid, ':', err);
              errorCount++;
              const { status } = findButtonForIid(row.iid);
              if (status) { status.textContent = 'Error'; status.style.color = '#a00'; }
            }
          });

          await Promise.all(promises);

          // Small delay between batches
          if (i + batchSize < recordsToUpdate.length) {
            await new Promise(resolve => setTimeout(resolve, 100));
          }
        }

        const resultMsg = `Bulk update (visible page) completed!\n✅ Successfully updated: ${successCount}\n❌ Errors: ${errorCount}`;
        alert(resultMsg);

        // Refresh the page to ensure consistency
        if (successCount > 0) renderPage(currentPage);

        bulkUpdateBtn.textContent = originalText;
        bulkUpdateBtn.disabled = false;
        bulkUpdateBtn.style.backgroundColor = '';

      } catch (err) {
        console.error('Bulk update error:', err);
        alert('Bulk update failed: ' + (err.message || err));
        bulkUpdateBtn.textContent = originalText;
        bulkUpdateBtn.disabled = false;
        bulkUpdateBtn.style.backgroundColor = '';
      }
    }

    function escapeHtml(s) {
      if (s === null || s === undefined) return '';
      return String(s).replace(/[&<>\\"']/g, c => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '\\"': '&quot;', "'": '&#39;' }[c]));
    }

    // close modal when clicking outside panel
    editModal.addEventListener('click', (e) => { if (e.target === editModal) closeModal(); });

    // Note: Load Students button removed - data loads automatically after auth verification
    // Bulk update button removed per request

    // Authentication check first, then data load
    (async function smartInitialWithAuth() {
      console.log('Smart initial with auth started');

      try {
        // Quick auth check first
        if (typeof window.supabase === 'undefined') {
          console.warn('Supabase not loaded, redirecting to login for security');
          window.location.href = './index.html';
          return;
        }

        // Reuse existing Supabase client
        const authClient = window.supabaseClient;
        const { data: { session }, error } = await authClient.auth.getSession();

        if (error || !session) {
          console.log('No valid session found, redirecting to login...');
          window.location.href = './index.html';
          return;
        }

        console.log('Authentication verified for user:', session.user && session.user.email ? session.user.email : '(no-email)');

        // Now that auth is verified, proceed with data loading
        console.log('Supabase available:', typeof window.supabase !== 'undefined');
        console.log('Status element:', statusEl);
        // Always load fresh data, no cache check
        console.log('Starting data load after auth verification...');
        loadData(false).then(() => console.log('Initial loadData() promise resolved')).catch(e => console.error('Initial loadData() failed:', e));

        // Setup auth state listener for future changes
        authClient.auth.onAuthStateChange((event, session) => {
          if (event === 'SIGNED_OUT' || (!session && event !== 'INITIAL_SESSION')) {
            console.log('User signed out, redirecting to login...');
            window.location.href = './index.html';
          }
        });

      } catch (error) {
        console.error('Auth check failed:', error);
        window.location.href = './index.html';
      }
    })();
  </script>
</body>

</html>